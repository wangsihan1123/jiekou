{"name": "插件管理-删除插件", "status": "broken", "statusDetails": {"message": "requests.exceptions.InvalidURL: Failed to parse: https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed", "trace": "url = 'https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n>               host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\nE               AttributeError: 'NoneType' object has no attribute 'groups'\n\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\urllib3\\util\\url.py:425: AttributeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <PreparedRequest [DELETE]>\nurl = 'https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed'\nparams = OrderedDict()\n\n    def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n    \n        # Remove leading whitespaces from url\n        url = url.lstrip()\n    \n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n    \n        # Support for unicode domain names and paths.\n        try:\n>           scheme, auth, host, port, path, query, fragment = parse_url(url)\n\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\requests\\models.py:434: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n                host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\n                if auth and normalize_uri:\n                    auth = _encode_invalid_chars(auth, _USERINFO_CHARS)\n                if port == \"\":\n                    port = None\n            else:\n                auth, host, port = None, None, None\n    \n            if port is not None:\n                port_int = int(port)\n                if not (0 <= port_int <= 65535):\n                    raise LocationParseError(url)\n            else:\n                port_int = None\n    \n            host = _normalize_host(host, scheme)\n    \n            if normalize_uri and path:\n                path = _remove_path_dot_segments(path)\n                path = _encode_invalid_chars(path, _PATH_CHARS)\n            if normalize_uri and query:\n                query = _encode_invalid_chars(query, _QUERY_CHARS)\n            if normalize_uri and fragment:\n                fragment = _encode_invalid_chars(fragment, _FRAGMENT_CHARS)\n    \n        except (ValueError, AttributeError) as e:\n>           raise LocationParseError(source_url) from e\nE           urllib3.exceptions.LocationParseError: Failed to parse: https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed\n\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\urllib3\\util\\url.py:451: LocationParseError\n\nDuring handling of the above exception, another exception occurred:\n\ndatas = {'case_id': 'TC003', 'data': '{\"name\":\"889\"}', 'expected': '{\"status_code\":200}', 'extractor': None, ...}\na_login = {'cookie': 'FULONGTECH_SESSION=9efe0598-4590-4bfd-9cf9-32e16eb44f54'}\n\n    @allure.title(\"插件管理-查询用户默认场景\")\n    @pytest.mark.parametrize('datas', excel_datas)\n    def test_01_workspace_mnt(datas, a_login):\n        \"\"\"插件管理-查询用户默认场景\"\"\"\n        datas = json.dumps(datas)\n    \n        if '#now_time_stamp#' in datas:\n            datas = datas.replace('#now_time_stamp#', str(Handler.now_time_stamp))\n    \n        # 替换\n        datas = Handler.replace_data(datas)\n        # 转化成字典\n        datas = json.loads(datas)\n    \n        allure.dynamic.title(datas[\"title\"])\n        allure.dynamic.description(\"测试{}接口.\".format(datas[\"title\"]))\n    \n        headers = json.loads(datas[\"headers\"])\n        headers[\"Cookie\"] = a_login[\"cookie\"]\n    \n        with allure.step('请求方式'):\n            allure.attach('{}'.format(datas[\"method\"]), name='{}请求方式'.format(datas[\"title\"]))\n    \n        with allure.step('请求路径'):\n            allure.attach('{}'.format(datas[\"path\"]), name='{}请求路径'.format(datas[\"title\"]))\n    \n        with allure.step('请求体'):\n            allure.attach('{}'.format(datas[\"data\"]), name='{}请求体'.format(datas[\"title\"]))\n        logger.info(\"{}请求路径为:{},请求体为:{}\".format(datas[\"title\"], datas[\"path\"], datas[\"data\"]))\n    \n        files = json.loads(datas[\"files\"])\n        if \"上传\" in datas[\"title\"]:\n            config_path = os.path.dirname(os.path.abspath(__file__))\n            root_path = os.path.dirname(config_path)\n            data_path = os.path.join(root_path, 'upload_files')\n            files = {\"file\": (files[\"file_name\"], open(data_path + files[\"file_path\"], \"rb\"), files[\"content_type\"])}\n    \n>       resp = requests.request(method=datas[\"method\"],\n                                url=Handler.env_config[\"env_url\"] + datas[\"path\"],\n                                headers=headers,\n                                files=files,\n                                json=json.loads(datas[\"data\"]),\n                                verify=False)\n\ntests\\test_01_workspace_mnt.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\requests\\api.py:59: in request\n    return session.request(method=method, url=url, **kwargs)\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\requests\\sessions.py:575: in request\n    prep = self.prepare_request(req)\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\requests\\sessions.py:486: in prepare_request\n    p.prepare(\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\requests\\models.py:368: in prepare\n    self.prepare_url(url, params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <PreparedRequest [DELETE]>\nurl = 'https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed'\nparams = OrderedDict()\n\n    def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n    \n        # Remove leading whitespaces from url\n        url = url.lstrip()\n    \n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n    \n        # Support for unicode domain names and paths.\n        try:\n            scheme, auth, host, port, path, query, fragment = parse_url(url)\n        except LocationParseError as e:\n>           raise InvalidURL(*e.args)\nE           requests.exceptions.InvalidURL: Failed to parse: https://10.10.10.121:4500OneHit/plugin/9e50661f-b6e4-44bb-a892-7384ff9b46ed\n\nC:\\Users\\wangsihan\\AppData\\Roaming\\Python\\Python38\\site-packages\\requests\\models.py:436: InvalidURL"}, "description": "测试插件管理-删除插件接口.", "steps": [{"name": "请求方式", "status": "passed", "attachments": [{"name": "插件管理-删除插件请求方式", "source": "2070da54-1639-4971-a1f1-35071f0adf7a-attachment.attach"}], "start": 1703663065500, "stop": 1703663065500}, {"name": "请求路径", "status": "passed", "attachments": [{"name": "插件管理-删除插件请求路径", "source": "392d4da1-5598-4ab1-8ad0-f7c11cef7922-attachment.attach"}], "start": 1703663065500, "stop": 1703663065501}, {"name": "请求体", "status": "passed", "attachments": [{"name": "插件管理-删除插件请求体", "source": "a92e60e7-59c4-446d-9831-12aee5d331e5-attachment.attach"}], "start": 1703663065501, "stop": 1703663065501}], "attachments": [{"name": "stderr", "source": "835fbb02-149f-4712-a160-5db0400bdd97-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "datas", "value": "{'case_id': 'TC003', 'title': '插件管理-删除插件', 'headers': '{}', 'path': 'OneHit/plugin/#uuid#', 'method': 'delete', 'files': '{}', 'data': '{\"name\":\"889\"}', 'expected': '{\"status_code\":200}', 'extractor': None}"}], "start": 1703663065499, "stop": 1703663065503, "uuid": "74de1c31-29bf-434e-ad86-38f7688553c3", "historyId": "beeade95c9b51192bfd66b99e64e39f5", "testCaseId": "4dce2d0bd632021e913ac9a6b569902a", "fullName": "tests.test_01_workspace_mnt#test_01_workspace_mnt", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_01_workspace_mnt"}, {"name": "host", "value": "wangsihan-PC"}, {"name": "thread", "value": "8320-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_01_workspace_mnt"}]}